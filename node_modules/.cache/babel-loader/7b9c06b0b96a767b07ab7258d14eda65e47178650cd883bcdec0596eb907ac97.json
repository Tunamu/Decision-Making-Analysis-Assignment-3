{"ast":null,"code":"import _isPlainObject from \"lodash/isPlainObject\";\nimport _defaults from \"lodash/defaults\";\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 1, 2, 45, 90, 135, 180, 225, 270, 315, 360] }]*/\nimport * as d3Shape from \"victory-vendor/d3-shape\";\nimport { Helpers, Data, Style } from \"victory-core\";\nconst checkForValidText = text => {\n  if (text === undefined || text === null || Helpers.isFunction(text)) {\n    return text;\n  }\n  return `${text}`;\n};\nconst getColor = (style, colors, index) => {\n  if (style && style.data && style.data.fill) {\n    return style.data.fill;\n  }\n  return colors && colors[index % colors.length];\n};\nconst getRadius = (props, padding) => {\n  if (typeof props.radius === \"number\") {\n    return props.radius;\n  }\n  return Math.min(props.width - padding.left - padding.right, props.height - padding.top - padding.bottom) / 2;\n};\nconst getOrigin = (props, padding) => {\n  const {\n    width,\n    height\n  } = props;\n  const origin = _isPlainObject(props.origin) ? props.origin : {};\n  return {\n    x: origin.x !== undefined ? origin.x : (padding.left - padding.right + width) / 2,\n    y: origin.y !== undefined ? origin.y : (padding.top - padding.bottom + height) / 2\n  };\n};\nconst getSlices = (props, data) => {\n  const padAngle = Helpers.isFunction(props.padAngle) ? 0 : props.padAngle;\n  const layoutFunction = d3Shape.pie().sort(null).startAngle(Helpers.degreesToRadians(props.startAngle)).endAngle(Helpers.degreesToRadians(props.endAngle)).padAngle(Helpers.degreesToRadians(padAngle)).value(datum => {\n    return datum._y;\n  });\n  return layoutFunction(data);\n};\nconst getCategoriesFromProps = props => Array.isArray(props.categories) ? props.categories : props?.categories?.x ?? [];\n\n/**\n * Sorts data by props.categories or props.categories.x. If all of the data keys aren't\n * included in categories, any remaining data will be appended to the data array.\n * If extraneous categories are included in the categories prop, the will be ignored and\n * have no effect on the rendered component.\n */\nconst getDataSortedByCategories = (props, data) => {\n  const sorted = [];\n  getCategoriesFromProps(props).forEach(category => {\n    const idx = data.findIndex(_ref => {\n      let {\n        x\n      } = _ref;\n      return x === category;\n    });\n    if (idx >= 0) {\n      const datum = data.splice(idx, 1)[0];\n      sorted.push(datum);\n    }\n  });\n  return [...sorted, ...data];\n};\nconst getCalculatedValues = props => {\n  const {\n    colorScale,\n    theme\n  } = props;\n  const styleObject = Helpers.getDefaultStyles(props, \"pie\");\n  const style = Helpers.getStyles(props.style, styleObject);\n  const colors = Array.isArray(colorScale) ? colorScale : Style.getColorScale(colorScale, theme);\n  const padding = Helpers.getPadding(props);\n  const defaultRadius = getRadius(props, padding);\n  const origin = getOrigin(props, padding);\n  const data = getDataSortedByCategories(props, Data.getData(props));\n  const slices = getSlices(props, data);\n  return Object.assign({}, props, {\n    style,\n    colors,\n    padding,\n    defaultRadius,\n    data,\n    slices,\n    origin\n  });\n};\nconst getSliceStyle = (index, calculatedValues) => {\n  const {\n    style,\n    colors\n  } = calculatedValues;\n  const fill = getColor(style, colors, index);\n  return Object.assign({\n    fill\n  }, style.data);\n};\nconst getLabelText = (props, datum, index) => {\n  let text;\n  if (datum.label) {\n    text = datum.label;\n  } else if (Array.isArray(props.labels)) {\n    text = props.labels[index];\n  } else {\n    text = Helpers.isFunction(props.labels) ? props.labels : datum.xName || datum._x;\n  }\n  return checkForValidText(text);\n};\nconst getLabelArc = labelRadius => {\n  return d3Shape.arc().outerRadius(labelRadius).innerRadius(labelRadius);\n};\nconst getCalculatedLabelRadius = (radius, labelRadius, style) => {\n  const padding = style && style.padding || 0;\n  return labelRadius || radius + padding;\n};\nconst getLabelPosition = (arc, slice, position) => {\n  const construct = {\n    startAngle: position === \"startAngle\" ? slice.startAngle : slice.endAngle,\n    endAngle: position === \"endAngle\" ? slice.endAngle : slice.startAngle\n  };\n  const clonedArc = Object.assign({}, slice, construct);\n  return arc.centroid(clonedArc);\n};\nconst getLabelOrientation = (degree, labelPlacement) => {\n  if (labelPlacement === \"perpendicular\") {\n    return degree > 90 && degree < 270 ? \"bottom\" : \"top\";\n  } else if (labelPlacement === \"parallel\") {\n    return degree >= 0 && degree <= 180 ? \"right\" : \"left\";\n  }\n  if (degree < 45 || degree > 315) {\n    return \"top\";\n  } else if (degree >= 45 && degree < 135) {\n    return \"right\";\n  } else if (degree >= 135 && degree < 225) {\n    return \"bottom\";\n  }\n  return \"left\";\n};\nconst getTextAnchor = orientation => {\n  if (orientation === \"top\" || orientation === \"bottom\") {\n    return \"middle\";\n  }\n  return orientation === \"right\" ? \"start\" : \"end\";\n};\nconst getVerticalAnchor = orientation => {\n  if (orientation === \"left\" || orientation === \"right\") {\n    return \"middle\";\n  }\n  return orientation === \"bottom\" ? \"start\" : \"end\";\n};\nconst getBaseLabelAngle = (slice, labelPosition, labelStyle) => {\n  let baseAngle = 0;\n  if (labelPosition.angle !== undefined) {\n    baseAngle = labelStyle.angle;\n  } else if (labelPosition === \"centroid\") {\n    baseAngle = Helpers.radiansToDegrees((slice.startAngle + slice.endAngle) / 2);\n  } else {\n    baseAngle = labelPosition === \"startAngle\" ? Helpers.radiansToDegrees(slice.startAngle) : Helpers.radiansToDegrees(slice.endAngle);\n  }\n  const positiveAngle = baseAngle < 0 ? 360 - baseAngle : baseAngle;\n  return positiveAngle % 360;\n};\nconst getLabelAngle = (baseAngle, labelPlacement) => {\n  if (labelPlacement === \"vertical\") {\n    return 0;\n  }\n  if (labelPlacement === \"parallel\") {\n    return baseAngle > 180 && baseAngle < 360 ? baseAngle + 90 : baseAngle - 90;\n  }\n  return baseAngle > 90 && baseAngle < 270 ? baseAngle - 180 : baseAngle;\n};\nconst getLabelProps = (text, dataProps, calculatedValues) => {\n  const {\n    index,\n    datum,\n    data,\n    slice,\n    labelComponent,\n    theme\n  } = dataProps;\n  const {\n    style,\n    defaultRadius,\n    origin,\n    width,\n    height\n  } = calculatedValues;\n  const labelRadius = Helpers.evaluateProp(calculatedValues.labelRadius, Object.assign({\n    text\n  }, dataProps));\n  const labelPosition = Helpers.evaluateProp(calculatedValues.labelPosition, Object.assign({\n    text\n  }, dataProps)) || \"centroid\";\n  const labelPlacement = Helpers.evaluateProp(calculatedValues.labelPlacement, Object.assign({\n    text\n  }, dataProps)) || \"vertical\";\n  const labelStyle = Object.assign({\n    padding: 0\n  }, style.labels);\n  const evaluatedStyle = Helpers.evaluateStyle(labelStyle, Object.assign({\n    labelRadius,\n    text\n  }, dataProps));\n  const calculatedLabelRadius = getCalculatedLabelRadius(defaultRadius, labelRadius, evaluatedStyle);\n  const labelArc = getLabelArc(calculatedLabelRadius);\n  const position = getLabelPosition(labelArc, slice, labelPosition);\n  const baseAngle = getBaseLabelAngle(slice, labelPosition, labelStyle);\n  const labelAngle = getLabelAngle(baseAngle, labelPlacement);\n  const orientation = getLabelOrientation(baseAngle, labelPlacement);\n  const textAnchor = labelStyle.textAnchor || getTextAnchor(orientation);\n  const verticalAnchor = labelStyle.verticalAnchor || getVerticalAnchor(orientation);\n  const labelProps = {\n    width,\n    height,\n    index,\n    datum,\n    data,\n    slice,\n    orientation,\n    text,\n    style: labelStyle,\n    x: Math.round(position[0]) + origin.x,\n    y: Math.round(position[1]) + origin.y,\n    textAnchor,\n    verticalAnchor,\n    angle: labelAngle,\n    calculatedLabelRadius\n  };\n  if (!Helpers.isTooltip(labelComponent)) {\n    return labelProps;\n  }\n  const tooltipTheme = theme && theme.tooltip || {};\n  return _defaults({}, labelProps, Helpers.omit(tooltipTheme, [\"style\"]));\n};\nexport const getXOffsetMultiplayerByAngle = angle => Math.cos(angle - Helpers.degreesToRadians(90));\nexport const getYOffsetMultiplayerByAngle = angle => Math.sin(angle - Helpers.degreesToRadians(90));\nexport const getXOffset = (offset, angle) => offset * getXOffsetMultiplayerByAngle(angle);\nexport const getYOffset = (offset, angle) => offset * getYOffsetMultiplayerByAngle(angle);\nexport const getAverage = array => array.reduce((acc, cur) => acc + cur, 0) / array.length;\nexport const getLabelIndicatorPropsForLineSegment = (props, calculatedValues, labelProps) => {\n  const {\n    innerRadius,\n    radius,\n    slice: {\n      startAngle,\n      endAngle\n    },\n    labelIndicatorInnerOffset,\n    labelIndicatorOuterOffset,\n    index\n  } = props;\n  const {\n    height,\n    width\n  } = calculatedValues;\n  const {\n    calculatedLabelRadius\n  } = labelProps;\n  // calculation\n  const middleRadius = getAverage([innerRadius, radius]);\n  const midAngle = getAverage([endAngle, startAngle]);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const innerOffset = middleRadius + labelIndicatorInnerOffset;\n  const outerOffset = calculatedLabelRadius - labelIndicatorOuterOffset;\n  const x1 = centerX + getXOffset(innerOffset, midAngle);\n  const y1 = centerY + getYOffset(innerOffset, midAngle);\n  const x2 = centerX + getXOffset(outerOffset, midAngle);\n  const y2 = centerY + getYOffset(outerOffset, midAngle);\n  const labelIndicatorProps = {\n    x1,\n    y1,\n    x2,\n    y2,\n    index\n  };\n  return _defaults({}, labelIndicatorProps);\n};\nexport const getBaseProps = (initialProps, fallbackProps) => {\n  const props = Helpers.modifyProps(initialProps, fallbackProps, \"pie\");\n  const calculatedValues = getCalculatedValues(props);\n  const {\n    slices,\n    style,\n    data,\n    origin,\n    defaultRadius,\n    labels,\n    events,\n    sharedEvents,\n    height,\n    width,\n    standalone,\n    name,\n    innerRadius,\n    cornerRadius,\n    padAngle,\n    disableInlineStyles,\n    labelIndicator\n  } = calculatedValues;\n  const radius = props.radius || defaultRadius;\n  const initialChildProps = {\n    parent: {\n      standalone,\n      height,\n      width,\n      slices,\n      name,\n      style: style.parent\n    }\n  };\n  return slices.reduce((childProps, slice, index) => {\n    const datum = _defaults({}, data[index], {\n      startAngle: Helpers.radiansToDegrees(slice.startAngle),\n      endAngle: Helpers.radiansToDegrees(slice.endAngle),\n      padAngle: Helpers.radiansToDegrees(slice.padAngle)\n    });\n    const eventKey = !Helpers.isNil(datum.eventKey) ? datum.eventKey : index;\n    const dataProps = {\n      index,\n      slice,\n      datum,\n      data,\n      origin,\n      innerRadius,\n      radius,\n      cornerRadius,\n      padAngle,\n      style: disableInlineStyles ? {} : getSliceStyle(index, calculatedValues),\n      disableInlineStyles\n    };\n    childProps[eventKey] = {\n      data: dataProps\n    };\n    const text = getLabelText(props, datum, index);\n    if (text !== undefined && text !== null || labels && (events || sharedEvents)) {\n      const evaluatedText = Helpers.evaluateProp(text, dataProps);\n      childProps[eventKey].labels = getLabelProps(evaluatedText, Object.assign({}, props, dataProps), calculatedValues);\n      if (labelIndicator) {\n        const labelProps = childProps[eventKey].labels;\n        if (labelProps.calculatedLabelRadius > radius) {\n          childProps[eventKey].labelIndicators = getLabelIndicatorPropsForLineSegment(Object.assign({}, props, dataProps), calculatedValues, labelProps);\n        }\n      }\n    }\n    return childProps;\n  }, initialChildProps);\n};","map":{"version":3,"names":["_isPlainObject","_defaults","d3Shape","Helpers","Data","Style","checkForValidText","text","undefined","isFunction","getColor","style","colors","index","data","fill","length","getRadius","props","padding","radius","Math","min","width","left","right","height","top","bottom","getOrigin","origin","x","y","getSlices","padAngle","layoutFunction","pie","sort","startAngle","degreesToRadians","endAngle","value","datum","_y","getCategoriesFromProps","Array","isArray","categories","getDataSortedByCategories","sorted","forEach","category","idx","findIndex","_ref","splice","push","getCalculatedValues","colorScale","theme","styleObject","getDefaultStyles","getStyles","getColorScale","getPadding","defaultRadius","getData","slices","Object","assign","getSliceStyle","calculatedValues","getLabelText","label","labels","xName","_x","getLabelArc","labelRadius","arc","outerRadius","innerRadius","getCalculatedLabelRadius","getLabelPosition","slice","position","construct","clonedArc","centroid","getLabelOrientation","degree","labelPlacement","getTextAnchor","orientation","getVerticalAnchor","getBaseLabelAngle","labelPosition","labelStyle","baseAngle","angle","radiansToDegrees","positiveAngle","getLabelAngle","getLabelProps","dataProps","labelComponent","evaluateProp","evaluatedStyle","evaluateStyle","calculatedLabelRadius","labelArc","labelAngle","textAnchor","verticalAnchor","labelProps","round","isTooltip","tooltipTheme","tooltip","omit","getXOffsetMultiplayerByAngle","cos","getYOffsetMultiplayerByAngle","sin","getXOffset","offset","getYOffset","getAverage","array","reduce","acc","cur","getLabelIndicatorPropsForLineSegment","labelIndicatorInnerOffset","labelIndicatorOuterOffset","middleRadius","midAngle","centerX","centerY","innerOffset","outerOffset","x1","y1","x2","y2","labelIndicatorProps","getBaseProps","initialProps","fallbackProps","modifyProps","events","sharedEvents","standalone","name","cornerRadius","disableInlineStyles","labelIndicator","initialChildProps","parent","childProps","eventKey","isNil","evaluatedText","labelIndicators"],"sources":["/Users/munatus/dev/react/node_modules/victory-pie/es/helper-methods.js"],"sourcesContent":["import _isPlainObject from \"lodash/isPlainObject\";\nimport _defaults from \"lodash/defaults\";\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 1, 2, 45, 90, 135, 180, 225, 270, 315, 360] }]*/\nimport * as d3Shape from \"victory-vendor/d3-shape\";\nimport { Helpers, Data, Style } from \"victory-core\";\nconst checkForValidText = text => {\n  if (text === undefined || text === null || Helpers.isFunction(text)) {\n    return text;\n  }\n  return `${text}`;\n};\nconst getColor = (style, colors, index) => {\n  if (style && style.data && style.data.fill) {\n    return style.data.fill;\n  }\n  return colors && colors[index % colors.length];\n};\nconst getRadius = (props, padding) => {\n  if (typeof props.radius === \"number\") {\n    return props.radius;\n  }\n  return Math.min(props.width - padding.left - padding.right, props.height - padding.top - padding.bottom) / 2;\n};\nconst getOrigin = (props, padding) => {\n  const {\n    width,\n    height\n  } = props;\n  const origin = _isPlainObject(props.origin) ? props.origin : {};\n  return {\n    x: origin.x !== undefined ? origin.x : (padding.left - padding.right + width) / 2,\n    y: origin.y !== undefined ? origin.y : (padding.top - padding.bottom + height) / 2\n  };\n};\nconst getSlices = (props, data) => {\n  const padAngle = Helpers.isFunction(props.padAngle) ? 0 : props.padAngle;\n  const layoutFunction = d3Shape.pie().sort(null).startAngle(Helpers.degreesToRadians(props.startAngle)).endAngle(Helpers.degreesToRadians(props.endAngle)).padAngle(Helpers.degreesToRadians(padAngle)).value(datum => {\n    return datum._y;\n  });\n  return layoutFunction(data);\n};\nconst getCategoriesFromProps = props => Array.isArray(props.categories) ? props.categories : props?.categories?.x ?? [];\n\n/**\n * Sorts data by props.categories or props.categories.x. If all of the data keys aren't\n * included in categories, any remaining data will be appended to the data array.\n * If extraneous categories are included in the categories prop, the will be ignored and\n * have no effect on the rendered component.\n */\nconst getDataSortedByCategories = (props, data) => {\n  const sorted = [];\n  getCategoriesFromProps(props).forEach(category => {\n    const idx = data.findIndex(_ref => {\n      let {\n        x\n      } = _ref;\n      return x === category;\n    });\n    if (idx >= 0) {\n      const datum = data.splice(idx, 1)[0];\n      sorted.push(datum);\n    }\n  });\n  return [...sorted, ...data];\n};\nconst getCalculatedValues = props => {\n  const {\n    colorScale,\n    theme\n  } = props;\n  const styleObject = Helpers.getDefaultStyles(props, \"pie\");\n  const style = Helpers.getStyles(props.style, styleObject);\n  const colors = Array.isArray(colorScale) ? colorScale : Style.getColorScale(colorScale, theme);\n  const padding = Helpers.getPadding(props);\n  const defaultRadius = getRadius(props, padding);\n  const origin = getOrigin(props, padding);\n  const data = getDataSortedByCategories(props, Data.getData(props));\n  const slices = getSlices(props, data);\n  return Object.assign({}, props, {\n    style,\n    colors,\n    padding,\n    defaultRadius,\n    data,\n    slices,\n    origin\n  });\n};\nconst getSliceStyle = (index, calculatedValues) => {\n  const {\n    style,\n    colors\n  } = calculatedValues;\n  const fill = getColor(style, colors, index);\n  return Object.assign({\n    fill\n  }, style.data);\n};\nconst getLabelText = (props, datum, index) => {\n  let text;\n  if (datum.label) {\n    text = datum.label;\n  } else if (Array.isArray(props.labels)) {\n    text = props.labels[index];\n  } else {\n    text = Helpers.isFunction(props.labels) ? props.labels : datum.xName || datum._x;\n  }\n  return checkForValidText(text);\n};\nconst getLabelArc = labelRadius => {\n  return d3Shape.arc().outerRadius(labelRadius).innerRadius(labelRadius);\n};\nconst getCalculatedLabelRadius = (radius, labelRadius, style) => {\n  const padding = style && style.padding || 0;\n  return labelRadius || radius + padding;\n};\nconst getLabelPosition = (arc, slice, position) => {\n  const construct = {\n    startAngle: position === \"startAngle\" ? slice.startAngle : slice.endAngle,\n    endAngle: position === \"endAngle\" ? slice.endAngle : slice.startAngle\n  };\n  const clonedArc = Object.assign({}, slice, construct);\n  return arc.centroid(clonedArc);\n};\nconst getLabelOrientation = (degree, labelPlacement) => {\n  if (labelPlacement === \"perpendicular\") {\n    return degree > 90 && degree < 270 ? \"bottom\" : \"top\";\n  } else if (labelPlacement === \"parallel\") {\n    return degree >= 0 && degree <= 180 ? \"right\" : \"left\";\n  }\n  if (degree < 45 || degree > 315) {\n    return \"top\";\n  } else if (degree >= 45 && degree < 135) {\n    return \"right\";\n  } else if (degree >= 135 && degree < 225) {\n    return \"bottom\";\n  }\n  return \"left\";\n};\nconst getTextAnchor = orientation => {\n  if (orientation === \"top\" || orientation === \"bottom\") {\n    return \"middle\";\n  }\n  return orientation === \"right\" ? \"start\" : \"end\";\n};\nconst getVerticalAnchor = orientation => {\n  if (orientation === \"left\" || orientation === \"right\") {\n    return \"middle\";\n  }\n  return orientation === \"bottom\" ? \"start\" : \"end\";\n};\nconst getBaseLabelAngle = (slice, labelPosition, labelStyle) => {\n  let baseAngle = 0;\n  if (labelPosition.angle !== undefined) {\n    baseAngle = labelStyle.angle;\n  } else if (labelPosition === \"centroid\") {\n    baseAngle = Helpers.radiansToDegrees((slice.startAngle + slice.endAngle) / 2);\n  } else {\n    baseAngle = labelPosition === \"startAngle\" ? Helpers.radiansToDegrees(slice.startAngle) : Helpers.radiansToDegrees(slice.endAngle);\n  }\n  const positiveAngle = baseAngle < 0 ? 360 - baseAngle : baseAngle;\n  return positiveAngle % 360;\n};\nconst getLabelAngle = (baseAngle, labelPlacement) => {\n  if (labelPlacement === \"vertical\") {\n    return 0;\n  }\n  if (labelPlacement === \"parallel\") {\n    return baseAngle > 180 && baseAngle < 360 ? baseAngle + 90 : baseAngle - 90;\n  }\n  return baseAngle > 90 && baseAngle < 270 ? baseAngle - 180 : baseAngle;\n};\nconst getLabelProps = (text, dataProps, calculatedValues) => {\n  const {\n    index,\n    datum,\n    data,\n    slice,\n    labelComponent,\n    theme\n  } = dataProps;\n  const {\n    style,\n    defaultRadius,\n    origin,\n    width,\n    height\n  } = calculatedValues;\n  const labelRadius = Helpers.evaluateProp(calculatedValues.labelRadius, Object.assign({\n    text\n  }, dataProps));\n  const labelPosition = Helpers.evaluateProp(calculatedValues.labelPosition, Object.assign({\n    text\n  }, dataProps)) || \"centroid\";\n  const labelPlacement = Helpers.evaluateProp(calculatedValues.labelPlacement, Object.assign({\n    text\n  }, dataProps)) || \"vertical\";\n  const labelStyle = Object.assign({\n    padding: 0\n  }, style.labels);\n  const evaluatedStyle = Helpers.evaluateStyle(labelStyle, Object.assign({\n    labelRadius,\n    text\n  }, dataProps));\n  const calculatedLabelRadius = getCalculatedLabelRadius(defaultRadius, labelRadius, evaluatedStyle);\n  const labelArc = getLabelArc(calculatedLabelRadius);\n  const position = getLabelPosition(labelArc, slice, labelPosition);\n  const baseAngle = getBaseLabelAngle(slice, labelPosition, labelStyle);\n  const labelAngle = getLabelAngle(baseAngle, labelPlacement);\n  const orientation = getLabelOrientation(baseAngle, labelPlacement);\n  const textAnchor = labelStyle.textAnchor || getTextAnchor(orientation);\n  const verticalAnchor = labelStyle.verticalAnchor || getVerticalAnchor(orientation);\n  const labelProps = {\n    width,\n    height,\n    index,\n    datum,\n    data,\n    slice,\n    orientation,\n    text,\n    style: labelStyle,\n    x: Math.round(position[0]) + origin.x,\n    y: Math.round(position[1]) + origin.y,\n    textAnchor,\n    verticalAnchor,\n    angle: labelAngle,\n    calculatedLabelRadius\n  };\n  if (!Helpers.isTooltip(labelComponent)) {\n    return labelProps;\n  }\n  const tooltipTheme = theme && theme.tooltip || {};\n  return _defaults({}, labelProps, Helpers.omit(tooltipTheme, [\"style\"]));\n};\nexport const getXOffsetMultiplayerByAngle = angle => Math.cos(angle - Helpers.degreesToRadians(90));\nexport const getYOffsetMultiplayerByAngle = angle => Math.sin(angle - Helpers.degreesToRadians(90));\nexport const getXOffset = (offset, angle) => offset * getXOffsetMultiplayerByAngle(angle);\nexport const getYOffset = (offset, angle) => offset * getYOffsetMultiplayerByAngle(angle);\nexport const getAverage = array => array.reduce((acc, cur) => acc + cur, 0) / array.length;\nexport const getLabelIndicatorPropsForLineSegment = (props, calculatedValues, labelProps) => {\n  const {\n    innerRadius,\n    radius,\n    slice: {\n      startAngle,\n      endAngle\n    },\n    labelIndicatorInnerOffset,\n    labelIndicatorOuterOffset,\n    index\n  } = props;\n  const {\n    height,\n    width\n  } = calculatedValues;\n  const {\n    calculatedLabelRadius\n  } = labelProps;\n  // calculation\n  const middleRadius = getAverage([innerRadius, radius]);\n  const midAngle = getAverage([endAngle, startAngle]);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const innerOffset = middleRadius + labelIndicatorInnerOffset;\n  const outerOffset = calculatedLabelRadius - labelIndicatorOuterOffset;\n  const x1 = centerX + getXOffset(innerOffset, midAngle);\n  const y1 = centerY + getYOffset(innerOffset, midAngle);\n  const x2 = centerX + getXOffset(outerOffset, midAngle);\n  const y2 = centerY + getYOffset(outerOffset, midAngle);\n  const labelIndicatorProps = {\n    x1,\n    y1,\n    x2,\n    y2,\n    index\n  };\n  return _defaults({}, labelIndicatorProps);\n};\nexport const getBaseProps = (initialProps, fallbackProps) => {\n  const props = Helpers.modifyProps(initialProps, fallbackProps, \"pie\");\n  const calculatedValues = getCalculatedValues(props);\n  const {\n    slices,\n    style,\n    data,\n    origin,\n    defaultRadius,\n    labels,\n    events,\n    sharedEvents,\n    height,\n    width,\n    standalone,\n    name,\n    innerRadius,\n    cornerRadius,\n    padAngle,\n    disableInlineStyles,\n    labelIndicator\n  } = calculatedValues;\n  const radius = props.radius || defaultRadius;\n  const initialChildProps = {\n    parent: {\n      standalone,\n      height,\n      width,\n      slices,\n      name,\n      style: style.parent\n    }\n  };\n  return slices.reduce((childProps, slice, index) => {\n    const datum = _defaults({}, data[index], {\n      startAngle: Helpers.radiansToDegrees(slice.startAngle),\n      endAngle: Helpers.radiansToDegrees(slice.endAngle),\n      padAngle: Helpers.radiansToDegrees(slice.padAngle)\n    });\n    const eventKey = !Helpers.isNil(datum.eventKey) ? datum.eventKey : index;\n    const dataProps = {\n      index,\n      slice,\n      datum,\n      data,\n      origin,\n      innerRadius,\n      radius,\n      cornerRadius,\n      padAngle,\n      style: disableInlineStyles ? {} : getSliceStyle(index, calculatedValues),\n      disableInlineStyles\n    };\n    childProps[eventKey] = {\n      data: dataProps\n    };\n    const text = getLabelText(props, datum, index);\n    if (text !== undefined && text !== null || labels && (events || sharedEvents)) {\n      const evaluatedText = Helpers.evaluateProp(text, dataProps);\n      childProps[eventKey].labels = getLabelProps(evaluatedText, Object.assign({}, props, dataProps), calculatedValues);\n      if (labelIndicator) {\n        const labelProps = childProps[eventKey].labels;\n        if (labelProps.calculatedLabelRadius > radius) {\n          childProps[eventKey].labelIndicators = getLabelIndicatorPropsForLineSegment(Object.assign({}, props, dataProps), calculatedValues, labelProps);\n        }\n      }\n    }\n    return childProps;\n  }, initialChildProps);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}