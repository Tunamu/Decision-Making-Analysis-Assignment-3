{"ast":null,"code":"import _uniqBy from \"lodash/uniqBy\";\nimport _groupBy from \"lodash/groupBy\";\nimport _uniq from \"lodash/uniq\";\nimport _defaults from \"lodash/defaults\";\nimport React from \"react\";\nimport * as Axis from \"./axis\";\nimport * as Style from \"./style\";\nimport * as Data from \"./data\";\nimport * as Domain from \"./domain\";\nimport * as Events from \"./events\";\nimport * as Collection from \"./collection\";\nimport * as Helpers from \"./helpers\";\nimport * as Scale from \"./scale\";\nimport * as Log from \"./log\";\nexport function addBinsToParentPropsIfHistogram(_ref) {\n  let {\n    children,\n    props,\n    childComponents,\n    parentProps\n  } = _ref;\n  const someChildrenAreHistograms = children.some(child => {\n    return child.type && child.type.role === \"histogram\";\n  });\n  const allChildrenAreHistograms = someChildrenAreHistograms && children.length && children.every(child => {\n    return child.type && child.type.role === \"histogram\";\n  });\n  if (someChildrenAreHistograms && !allChildrenAreHistograms) {\n    Log.warn(\"VictoryHistogram only supports being stacked with other VictoryHistogram components. Check to make sure that you are only passing VictoryHistogram components to VictoryStack\");\n  }\n\n  // if we are stacking histograms, we need to generate explicit bins\n  // or else each histogram may end up having different bins\n  if (!allChildrenAreHistograms) {\n    return parentProps;\n  }\n  let childBins = props.bins || childComponents[0].props.bins;\n\n  // if we have explicit bins then we don't need to calculate them\n  if (!Array.isArray(childBins)) {\n    const combinedData = children.reduce((memo, child) => {\n      const xAccessor = Helpers.createAccessor(child.props.x || \"x\");\n      return memo.concat(child.props.data.map(datum => ({\n        x: xAccessor(datum)\n      })));\n    }, []);\n\n    // use the same function to generate bins as VictoryHistogram but with\n    // the combined data from above, then get explicit bins from that\n    const getFormattedHistogramData = children[0].type.getFormattedData;\n    childBins = getFormattedHistogramData({\n      data: combinedData,\n      bins: childBins\n    }).reduce((memo, _ref2, index) => {\n      let {\n        x0,\n        x1\n      } = _ref2;\n      return index === 0 ? memo.concat([x0, x1]) : memo.concat(x1);\n    }, []);\n  }\n  return {\n    ...parentProps,\n    bins: childBins\n  };\n}\nexport function getDataFromChildren(props, childComponents) {\n  const {\n    polar,\n    startAngle,\n    endAngle,\n    categories,\n    minDomain,\n    maxDomain\n  } = props;\n  let parentProps = {\n    polar,\n    startAngle,\n    endAngle,\n    categories,\n    minDomain,\n    maxDomain\n  };\n  let stack = 0;\n  const children = childComponents ? childComponents.slice(0) : React.Children.toArray(props.children);\n  parentProps = addBinsToParentPropsIfHistogram({\n    children,\n    props,\n    childComponents,\n    parentProps\n  });\n  const iteratee = (child, childName, parent) => {\n    const childProps = Object.assign({}, child.props, parentProps);\n    let childData;\n    let childElement = child;\n    if (!Data.isDataComponent(child)) {\n      return null;\n    } else if (child.type && Helpers.isFunction(child.type.getData)) {\n      childElement = parent ? /*#__PURE__*/React.cloneElement(child, parent.props) : child;\n      childData = childElement.type.getData(childProps);\n    } else {\n      childData = Data.getData(childProps);\n    }\n    stack += 1;\n    return childData.map((datum, index) => Object.assign({\n      _stack: stack,\n      _group: index\n    }, datum));\n  };\n  const stacked = children.filter(c => c.type && c.type.role === \"stack\").length;\n  const combine = (memo, val) => memo.concat(_uniqBy(val, \"_group\"));\n  const datasets = Helpers.reduceChildren(children, iteratee, props, [], combine);\n  const group = stacked ? \"_group\" : \"_stack\";\n  return Object.values(_groupBy(datasets, group));\n}\nexport function getData(props, childComponents) {\n  if (props.data) {\n    return Data.getData(props);\n  }\n  return getDataFromChildren(props, childComponents || React.Children.toArray(props.children));\n}\nexport function getWidth(props, groupLength, seriesLength) {\n  const {\n    datasets,\n    horizontal\n  } = props;\n  const range = horizontal ? Helpers.getRange(props, \"y\") : Helpers.getRange(props, \"x\");\n  const extent = Math.abs(range[1] - range[0]);\n  const seriesLengthValue = seriesLength !== undefined ? seriesLength : Array.isArray(datasets[0]) && datasets[0].length || 1;\n  const groupLengthValue = groupLength || datasets.length;\n  const bars = groupLengthValue * seriesLengthValue;\n  const barRatio = 0.5;\n  return Math.round(barRatio * extent / bars);\n}\nexport function getDefaultDomainPadding(props, axis, childComponents) {\n  if (props.polar || axis !== \"x\") {\n    return undefined;\n  }\n  const groupComponent = childComponents.filter(child => {\n    return child.type && child.type.role && child.type.role === \"group\";\n  });\n  if (groupComponent.length < 1) {\n    return undefined;\n  }\n  const {\n    offset,\n    children\n  } = groupComponent[0].props;\n  if (!offset) {\n    return undefined;\n  }\n  const firstChild = Array.isArray(children) && children[0];\n  if (!firstChild) {\n    return undefined;\n  }\n  let barWidth = firstChild.props.barWidth;\n  let dataLength = firstChild.props.data && firstChild.props.data.length || 1;\n  if (firstChild && firstChild.type.role === \"stack\") {\n    const nestedChild = firstChild.props.children && firstChild.props.children[0];\n    if (!nestedChild) {\n      return undefined;\n    }\n    barWidth = nestedChild.props.barWidth;\n    dataLength = firstChild.props.children.length;\n  }\n  const width = barWidth || getWidth(props, children.length, dataLength);\n  return {\n    x: width * children.length / 2 + (offset - width * ((children.length - 1) / 2))\n  };\n}\nexport function getDomainFromChildren(props, axis, childComponents) {\n  // eslint-disable-line max-statements, complexity, max-len\n  const children = childComponents ? childComponents.slice(0) : React.Children.toArray(props.children);\n  const parentData = props.data ? Data.getData(props) : undefined;\n  const {\n    polar,\n    startAngle,\n    endAngle,\n    categories,\n    minDomain,\n    maxDomain,\n    horizontal\n  } = props;\n  const baseParentProps = {\n    horizontal,\n    polar,\n    startAngle,\n    endAngle,\n    minDomain,\n    maxDomain,\n    categories\n  };\n  const parentProps = parentData ? Object.assign(baseParentProps, {\n    data: parentData\n  }) : baseParentProps;\n  const iteratee = child => {\n    const sharedProps = Object.assign({}, child.props, parentProps);\n    if (!Domain.isDomainComponent(child)) {\n      return null;\n    } else if (child.type && Helpers.isFunction(child.type.getDomain)) {\n      return child.props && child.type.getDomain(sharedProps, axis);\n    }\n    return Domain.getDomain(sharedProps, axis);\n  };\n  const childDomains = Helpers.reduceChildren(children, iteratee, props);\n  const min = childDomains.length === 0 ? 0 : Collection.getMinValue(childDomains);\n  const max = childDomains.length === 0 ? 1 : Collection.getMaxValue(childDomains);\n  return [min, max];\n}\nexport function getDomain(props, axis, childComponents) {\n  const children = childComponents || React.Children.toArray(props.children);\n  const propsDomain = Domain.getDomainFromProps(props, axis);\n  const domainPadding = getDefaultDomainPadding(props, axis, children);\n  let domain;\n  if (propsDomain) {\n    domain = propsDomain;\n  } else {\n    const minDomain = Domain.getMinFromProps(props, axis);\n    const maxDomain = Domain.getMaxFromProps(props, axis);\n    const dataset = (props.data || props.y) && Data.getData(props);\n    const dataDomain = dataset ? Domain.getDomainFromData(props, axis, dataset) : [];\n    const childDomain = getDomainFromChildren(props, axis, children);\n    const min = minDomain || Collection.getMinValue([...dataDomain, ...childDomain]);\n    const max = maxDomain || Collection.getMaxValue([...dataDomain, ...childDomain]);\n    domain = Domain.getDomainFromMinMax(min, max);\n  }\n  return Domain.formatDomain(domain, Object.assign({\n    domainPadding\n  }, props), axis);\n}\nexport function getScale(props, axis, childComponents) {\n  if (props.data) {\n    return Scale.getBaseScale(props, axis);\n  }\n  const children = childComponents ? childComponents.slice(0) : React.Children.toArray(props.children);\n  const iteratee = child => {\n    const sharedProps = Object.assign({}, child.props, {\n      horizontal: props.horizontal\n    });\n    return Scale.getScaleType(sharedProps, axis);\n  };\n  const childScale = _uniq(Helpers.reduceChildren(children, iteratee, props));\n\n  // default to linear scale if more than one uniq scale type is given by children\n  return childScale.length > 1 ? Scale.getScaleFromName(\"linear\") : Scale.getScaleFromName(childScale[0]);\n}\nexport function getAllEvents(props) {\n  const components = [\"groupComponent\", \"containerComponent\", \"labelComponent\"];\n  const componentEvents = Events.getComponentEvents(props, components);\n  let events = props.events;\n  if (Array.isArray(componentEvents)) {\n    events = Array.isArray(props.events) ? componentEvents.concat(...props.events) : componentEvents;\n  }\n  return events || [];\n}\n\n// eslint-disable-next-line max-params\nexport function getColor(calculatedProps, child, index, theme) {\n  // check for styles first\n  const {\n    style\n  } = calculatedProps;\n  let {\n    colorScale,\n    color\n  } = calculatedProps;\n  if (style && style.data && style.data.fill) {\n    return style.data.fill;\n  }\n  colorScale = child.props && child.props.colorScale ? child.props.colorScale : colorScale;\n  color = child.props && child.props.color ? child.props.color : color;\n  if (!colorScale && !color) {\n    return undefined;\n  }\n  const colors = Array.isArray(colorScale) ? colorScale : Style.getColorScale(colorScale, theme);\n  return color || colors[index % colors.length];\n}\nexport function getStyle(theme, style, role) {\n  const defaultStyle = theme && theme[role] && theme[role].style ? theme[role].style : {};\n  return Helpers.getStyles(style, defaultStyle);\n}\n\n// eslint-disable-next-line max-params\nexport function getChildStyle(child, index, calculatedProps, theme) {\n  const {\n    style,\n    role\n  } = calculatedProps;\n  const childStyle = child.props.style || {};\n  if (Array.isArray(childStyle)) {\n    return childStyle;\n  }\n  const childRole = child.type && child.type.role;\n  const defaultFill = childRole === \"stack\" ? undefined : getColor(calculatedProps, child, index, theme);\n  const defaultColor = childRole === \"line\" ? {\n    fill: \"none\",\n    stroke: defaultFill\n  } : {\n    fill: defaultFill\n  };\n  const dataWidth = role === \"stack\" ? {} : {\n    width: getWidth(calculatedProps)\n  };\n  const dataStyle = _defaults({}, childStyle.data, Object.assign({}, dataWidth, style.data, defaultColor));\n  const labelsStyle = _defaults({}, childStyle.labels, style.labels);\n  return {\n    ...childStyle,\n    parent: style.parent,\n    data: dataStyle,\n    labels: labelsStyle\n  };\n}\nexport function getStringsFromChildrenCategories(childComponents, axis) {\n  const iteratee = child => {\n    if (!Domain.isDomainComponent(child)) {\n      return null;\n    }\n    const childProps = child.props || {};\n    return Data.getStringsFromCategories(childProps, axis);\n  };\n  return Helpers.reduceChildren(childComponents.slice(0), iteratee);\n}\nexport function getStringsFromData(childComponents) {\n  const iteratee = child => {\n    const childProps = child.props || {};\n    let data;\n    if (!Data.isDataComponent(child)) {\n      return null;\n    } else if (child.type && Helpers.isFunction(child.type.getData)) {\n      data = child.type.getData(childProps);\n    } else {\n      data = Data.getData(childProps);\n    }\n    return data.map(d => ({\n      x: d.xName,\n      y: d.yName\n    }));\n  };\n  const initialMemo = {\n    x: [],\n    y: []\n  };\n  const combine = (memo, datum) => {\n    const x = Array.isArray(datum) ? datum.map(d => d.x).filter(Boolean) : datum.x;\n    const y = Array.isArray(datum) ? datum.map(d => d.y).filter(Boolean) : datum.y;\n    return {\n      x: x !== undefined ? memo.x.concat(x) : memo.x,\n      y: y !== undefined ? memo.y.concat(y) : memo.y\n    };\n  };\n  return Helpers.reduceChildren(childComponents.slice(0), iteratee, {}, initialMemo, combine);\n}\nexport function getCategoryAndAxisStringsFromChildren(props, axis, childComponents) {\n  const categories = Data.getStringsFromCategories(props, axis);\n  const axisComponent = Axis.getAxisComponent(childComponents, axis);\n  const axisStrings = axisComponent ? Data.getStringsFromAxes(axisComponent.props, axis) : [];\n  const categoryStrings = categories.length ? categories : getStringsFromChildrenCategories(childComponents, axis);\n  return _uniq([...categoryStrings, ...axisStrings].flat());\n}\nexport function getStringsFromChildren(props, childComponents) {\n  const children = childComponents || React.Children.toArray(props.children);\n  const xStrings = getCategoryAndAxisStringsFromChildren(props, \"x\", children);\n  const yStrings = getCategoryAndAxisStringsFromChildren(props, \"y\", children);\n  const dataStrings = getStringsFromData(children);\n  return {\n    x: _uniq([...xStrings, ...dataStrings.x].flat()),\n    y: _uniq([...yStrings, ...dataStrings.y].flat())\n  };\n}\nexport function getCategories(props, childComponents, allStrings) {\n  const xPropCategories = props.categories && Data.getStringsFromCategories(props, \"x\");\n  const yPropCategories = props.categories && Data.getStringsFromCategories(props, \"y\");\n  const fallbackRequired = !xPropCategories || !yPropCategories;\n  const fallbackProps = fallbackRequired ? allStrings || getStringsFromChildren(props, childComponents) : {};\n  const xCategories = xPropCategories || fallbackProps.x;\n  const yCategories = yPropCategories || fallbackProps.y;\n  return {\n    x: xCategories.length > 0 ? xCategories : undefined,\n    y: yCategories.length > 0 ? yCategories : undefined\n  };\n}","map":{"version":3,"names":["_uniqBy","_groupBy","_uniq","_defaults","React","Axis","Style","Data","Domain","Events","Collection","Helpers","Scale","Log","addBinsToParentPropsIfHistogram","_ref","children","props","childComponents","parentProps","someChildrenAreHistograms","some","child","type","role","allChildrenAreHistograms","length","every","warn","childBins","bins","Array","isArray","combinedData","reduce","memo","xAccessor","createAccessor","x","concat","data","map","datum","getFormattedHistogramData","getFormattedData","_ref2","index","x0","x1","getDataFromChildren","polar","startAngle","endAngle","categories","minDomain","maxDomain","stack","slice","Children","toArray","iteratee","childName","parent","childProps","Object","assign","childData","childElement","isDataComponent","isFunction","getData","cloneElement","_stack","_group","stacked","filter","c","combine","val","datasets","reduceChildren","group","values","getWidth","groupLength","seriesLength","horizontal","range","getRange","extent","Math","abs","seriesLengthValue","undefined","groupLengthValue","bars","barRatio","round","getDefaultDomainPadding","axis","groupComponent","offset","firstChild","barWidth","dataLength","nestedChild","width","getDomainFromChildren","parentData","baseParentProps","sharedProps","isDomainComponent","getDomain","childDomains","min","getMinValue","max","getMaxValue","propsDomain","getDomainFromProps","domainPadding","domain","getMinFromProps","getMaxFromProps","dataset","y","dataDomain","getDomainFromData","childDomain","getDomainFromMinMax","formatDomain","getScale","getBaseScale","getScaleType","childScale","getScaleFromName","getAllEvents","components","componentEvents","getComponentEvents","events","getColor","calculatedProps","theme","style","colorScale","color","fill","colors","getColorScale","getStyle","defaultStyle","getStyles","getChildStyle","childStyle","childRole","defaultFill","defaultColor","stroke","dataWidth","dataStyle","labelsStyle","labels","getStringsFromChildrenCategories","getStringsFromCategories","getStringsFromData","d","xName","yName","initialMemo","Boolean","getCategoryAndAxisStringsFromChildren","axisComponent","getAxisComponent","axisStrings","getStringsFromAxes","categoryStrings","flat","getStringsFromChildren","xStrings","yStrings","dataStrings","getCategories","allStrings","xPropCategories","yPropCategories","fallbackRequired","fallbackProps","xCategories","yCategories"],"sources":["/Users/munatus/dev/react/assignment-2/node_modules/victory-core/es/victory-util/wrapper.js"],"sourcesContent":["import _uniqBy from \"lodash/uniqBy\";\nimport _groupBy from \"lodash/groupBy\";\nimport _uniq from \"lodash/uniq\";\nimport _defaults from \"lodash/defaults\";\nimport React from \"react\";\nimport * as Axis from \"./axis\";\nimport * as Style from \"./style\";\nimport * as Data from \"./data\";\nimport * as Domain from \"./domain\";\nimport * as Events from \"./events\";\nimport * as Collection from \"./collection\";\nimport * as Helpers from \"./helpers\";\nimport * as Scale from \"./scale\";\nimport * as Log from \"./log\";\nexport function addBinsToParentPropsIfHistogram(_ref) {\n  let {\n    children,\n    props,\n    childComponents,\n    parentProps\n  } = _ref;\n  const someChildrenAreHistograms = children.some(child => {\n    return child.type && child.type.role === \"histogram\";\n  });\n  const allChildrenAreHistograms = someChildrenAreHistograms && children.length && children.every(child => {\n    return child.type && child.type.role === \"histogram\";\n  });\n  if (someChildrenAreHistograms && !allChildrenAreHistograms) {\n    Log.warn(\"VictoryHistogram only supports being stacked with other VictoryHistogram components. Check to make sure that you are only passing VictoryHistogram components to VictoryStack\");\n  }\n\n  // if we are stacking histograms, we need to generate explicit bins\n  // or else each histogram may end up having different bins\n  if (!allChildrenAreHistograms) {\n    return parentProps;\n  }\n  let childBins = props.bins || childComponents[0].props.bins;\n\n  // if we have explicit bins then we don't need to calculate them\n  if (!Array.isArray(childBins)) {\n    const combinedData = children.reduce((memo, child) => {\n      const xAccessor = Helpers.createAccessor(child.props.x || \"x\");\n      return memo.concat(child.props.data.map(datum => ({\n        x: xAccessor(datum)\n      })));\n    }, []);\n\n    // use the same function to generate bins as VictoryHistogram but with\n    // the combined data from above, then get explicit bins from that\n    const getFormattedHistogramData = children[0].type.getFormattedData;\n    childBins = getFormattedHistogramData({\n      data: combinedData,\n      bins: childBins\n    }).reduce((memo, _ref2, index) => {\n      let {\n        x0,\n        x1\n      } = _ref2;\n      return index === 0 ? memo.concat([x0, x1]) : memo.concat(x1);\n    }, []);\n  }\n  return {\n    ...parentProps,\n    bins: childBins\n  };\n}\nexport function getDataFromChildren(props, childComponents) {\n  const {\n    polar,\n    startAngle,\n    endAngle,\n    categories,\n    minDomain,\n    maxDomain\n  } = props;\n  let parentProps = {\n    polar,\n    startAngle,\n    endAngle,\n    categories,\n    minDomain,\n    maxDomain\n  };\n  let stack = 0;\n  const children = childComponents ? childComponents.slice(0) : React.Children.toArray(props.children);\n  parentProps = addBinsToParentPropsIfHistogram({\n    children,\n    props,\n    childComponents,\n    parentProps\n  });\n  const iteratee = (child, childName, parent) => {\n    const childProps = Object.assign({}, child.props, parentProps);\n    let childData;\n    let childElement = child;\n    if (!Data.isDataComponent(child)) {\n      return null;\n    } else if (child.type && Helpers.isFunction(child.type.getData)) {\n      childElement = parent ? /*#__PURE__*/React.cloneElement(child, parent.props) : child;\n      childData = childElement.type.getData(childProps);\n    } else {\n      childData = Data.getData(childProps);\n    }\n    stack += 1;\n    return childData.map((datum, index) => Object.assign({\n      _stack: stack,\n      _group: index\n    }, datum));\n  };\n  const stacked = children.filter(c => c.type && c.type.role === \"stack\").length;\n  const combine = (memo, val) => memo.concat(_uniqBy(val, \"_group\"));\n  const datasets = Helpers.reduceChildren(children, iteratee, props, [], combine);\n  const group = stacked ? \"_group\" : \"_stack\";\n  return Object.values(_groupBy(datasets, group));\n}\nexport function getData(props, childComponents) {\n  if (props.data) {\n    return Data.getData(props);\n  }\n  return getDataFromChildren(props, childComponents || React.Children.toArray(props.children));\n}\nexport function getWidth(props, groupLength, seriesLength) {\n  const {\n    datasets,\n    horizontal\n  } = props;\n  const range = horizontal ? Helpers.getRange(props, \"y\") : Helpers.getRange(props, \"x\");\n  const extent = Math.abs(range[1] - range[0]);\n  const seriesLengthValue = seriesLength !== undefined ? seriesLength : Array.isArray(datasets[0]) && datasets[0].length || 1;\n  const groupLengthValue = groupLength || datasets.length;\n  const bars = groupLengthValue * seriesLengthValue;\n  const barRatio = 0.5;\n  return Math.round(barRatio * extent / bars);\n}\nexport function getDefaultDomainPadding(props, axis, childComponents) {\n  if (props.polar || axis !== \"x\") {\n    return undefined;\n  }\n  const groupComponent = childComponents.filter(child => {\n    return child.type && child.type.role && child.type.role === \"group\";\n  });\n  if (groupComponent.length < 1) {\n    return undefined;\n  }\n  const {\n    offset,\n    children\n  } = groupComponent[0].props;\n  if (!offset) {\n    return undefined;\n  }\n  const firstChild = Array.isArray(children) && children[0];\n  if (!firstChild) {\n    return undefined;\n  }\n  let barWidth = firstChild.props.barWidth;\n  let dataLength = firstChild.props.data && firstChild.props.data.length || 1;\n  if (firstChild && firstChild.type.role === \"stack\") {\n    const nestedChild = firstChild.props.children && firstChild.props.children[0];\n    if (!nestedChild) {\n      return undefined;\n    }\n    barWidth = nestedChild.props.barWidth;\n    dataLength = firstChild.props.children.length;\n  }\n  const width = barWidth || getWidth(props, children.length, dataLength);\n  return {\n    x: width * children.length / 2 + (offset - width * ((children.length - 1) / 2))\n  };\n}\nexport function getDomainFromChildren(props, axis, childComponents) {\n  // eslint-disable-line max-statements, complexity, max-len\n  const children = childComponents ? childComponents.slice(0) : React.Children.toArray(props.children);\n  const parentData = props.data ? Data.getData(props) : undefined;\n  const {\n    polar,\n    startAngle,\n    endAngle,\n    categories,\n    minDomain,\n    maxDomain,\n    horizontal\n  } = props;\n  const baseParentProps = {\n    horizontal,\n    polar,\n    startAngle,\n    endAngle,\n    minDomain,\n    maxDomain,\n    categories\n  };\n  const parentProps = parentData ? Object.assign(baseParentProps, {\n    data: parentData\n  }) : baseParentProps;\n  const iteratee = child => {\n    const sharedProps = Object.assign({}, child.props, parentProps);\n    if (!Domain.isDomainComponent(child)) {\n      return null;\n    } else if (child.type && Helpers.isFunction(child.type.getDomain)) {\n      return child.props && child.type.getDomain(sharedProps, axis);\n    }\n    return Domain.getDomain(sharedProps, axis);\n  };\n  const childDomains = Helpers.reduceChildren(children, iteratee, props);\n  const min = childDomains.length === 0 ? 0 : Collection.getMinValue(childDomains);\n  const max = childDomains.length === 0 ? 1 : Collection.getMaxValue(childDomains);\n  return [min, max];\n}\nexport function getDomain(props, axis, childComponents) {\n  const children = childComponents || React.Children.toArray(props.children);\n  const propsDomain = Domain.getDomainFromProps(props, axis);\n  const domainPadding = getDefaultDomainPadding(props, axis, children);\n  let domain;\n  if (propsDomain) {\n    domain = propsDomain;\n  } else {\n    const minDomain = Domain.getMinFromProps(props, axis);\n    const maxDomain = Domain.getMaxFromProps(props, axis);\n    const dataset = (props.data || props.y) && Data.getData(props);\n    const dataDomain = dataset ? Domain.getDomainFromData(props, axis, dataset) : [];\n    const childDomain = getDomainFromChildren(props, axis, children);\n    const min = minDomain || Collection.getMinValue([...dataDomain, ...childDomain]);\n    const max = maxDomain || Collection.getMaxValue([...dataDomain, ...childDomain]);\n    domain = Domain.getDomainFromMinMax(min, max);\n  }\n  return Domain.formatDomain(domain, Object.assign({\n    domainPadding\n  }, props), axis);\n}\nexport function getScale(props, axis, childComponents) {\n  if (props.data) {\n    return Scale.getBaseScale(props, axis);\n  }\n  const children = childComponents ? childComponents.slice(0) : React.Children.toArray(props.children);\n  const iteratee = child => {\n    const sharedProps = Object.assign({}, child.props, {\n      horizontal: props.horizontal\n    });\n    return Scale.getScaleType(sharedProps, axis);\n  };\n  const childScale = _uniq(Helpers.reduceChildren(children, iteratee, props));\n\n  // default to linear scale if more than one uniq scale type is given by children\n  return childScale.length > 1 ? Scale.getScaleFromName(\"linear\") : Scale.getScaleFromName(childScale[0]);\n}\nexport function getAllEvents(props) {\n  const components = [\"groupComponent\", \"containerComponent\", \"labelComponent\"];\n  const componentEvents = Events.getComponentEvents(props, components);\n  let events = props.events;\n  if (Array.isArray(componentEvents)) {\n    events = Array.isArray(props.events) ? componentEvents.concat(...props.events) : componentEvents;\n  }\n  return events || [];\n}\n\n// eslint-disable-next-line max-params\nexport function getColor(calculatedProps, child, index, theme) {\n  // check for styles first\n  const {\n    style\n  } = calculatedProps;\n  let {\n    colorScale,\n    color\n  } = calculatedProps;\n  if (style && style.data && style.data.fill) {\n    return style.data.fill;\n  }\n  colorScale = child.props && child.props.colorScale ? child.props.colorScale : colorScale;\n  color = child.props && child.props.color ? child.props.color : color;\n  if (!colorScale && !color) {\n    return undefined;\n  }\n  const colors = Array.isArray(colorScale) ? colorScale : Style.getColorScale(colorScale, theme);\n  return color || colors[index % colors.length];\n}\nexport function getStyle(theme, style, role) {\n  const defaultStyle = theme && theme[role] && theme[role].style ? theme[role].style : {};\n  return Helpers.getStyles(style, defaultStyle);\n}\n\n// eslint-disable-next-line max-params\nexport function getChildStyle(child, index, calculatedProps, theme) {\n  const {\n    style,\n    role\n  } = calculatedProps;\n  const childStyle = child.props.style || {};\n  if (Array.isArray(childStyle)) {\n    return childStyle;\n  }\n  const childRole = child.type && child.type.role;\n  const defaultFill = childRole === \"stack\" ? undefined : getColor(calculatedProps, child, index, theme);\n  const defaultColor = childRole === \"line\" ? {\n    fill: \"none\",\n    stroke: defaultFill\n  } : {\n    fill: defaultFill\n  };\n  const dataWidth = role === \"stack\" ? {} : {\n    width: getWidth(calculatedProps)\n  };\n  const dataStyle = _defaults({}, childStyle.data, Object.assign({}, dataWidth, style.data, defaultColor));\n  const labelsStyle = _defaults({}, childStyle.labels, style.labels);\n  return {\n    ...childStyle,\n    parent: style.parent,\n    data: dataStyle,\n    labels: labelsStyle\n  };\n}\nexport function getStringsFromChildrenCategories(childComponents, axis) {\n  const iteratee = child => {\n    if (!Domain.isDomainComponent(child)) {\n      return null;\n    }\n    const childProps = child.props || {};\n    return Data.getStringsFromCategories(childProps, axis);\n  };\n  return Helpers.reduceChildren(childComponents.slice(0), iteratee);\n}\nexport function getStringsFromData(childComponents) {\n  const iteratee = child => {\n    const childProps = child.props || {};\n    let data;\n    if (!Data.isDataComponent(child)) {\n      return null;\n    } else if (child.type && Helpers.isFunction(child.type.getData)) {\n      data = child.type.getData(childProps);\n    } else {\n      data = Data.getData(childProps);\n    }\n    return data.map(d => ({\n      x: d.xName,\n      y: d.yName\n    }));\n  };\n  const initialMemo = {\n    x: [],\n    y: []\n  };\n  const combine = (memo, datum) => {\n    const x = Array.isArray(datum) ? datum.map(d => d.x).filter(Boolean) : datum.x;\n    const y = Array.isArray(datum) ? datum.map(d => d.y).filter(Boolean) : datum.y;\n    return {\n      x: x !== undefined ? memo.x.concat(x) : memo.x,\n      y: y !== undefined ? memo.y.concat(y) : memo.y\n    };\n  };\n  return Helpers.reduceChildren(childComponents.slice(0), iteratee, {}, initialMemo, combine);\n}\nexport function getCategoryAndAxisStringsFromChildren(props, axis, childComponents) {\n  const categories = Data.getStringsFromCategories(props, axis);\n  const axisComponent = Axis.getAxisComponent(childComponents, axis);\n  const axisStrings = axisComponent ? Data.getStringsFromAxes(axisComponent.props, axis) : [];\n  const categoryStrings = categories.length ? categories : getStringsFromChildrenCategories(childComponents, axis);\n  return _uniq([...categoryStrings, ...axisStrings].flat());\n}\nexport function getStringsFromChildren(props, childComponents) {\n  const children = childComponents || React.Children.toArray(props.children);\n  const xStrings = getCategoryAndAxisStringsFromChildren(props, \"x\", children);\n  const yStrings = getCategoryAndAxisStringsFromChildren(props, \"y\", children);\n  const dataStrings = getStringsFromData(children);\n  return {\n    x: _uniq([...xStrings, ...dataStrings.x].flat()),\n    y: _uniq([...yStrings, ...dataStrings.y].flat())\n  };\n}\nexport function getCategories(props, childComponents, allStrings) {\n  const xPropCategories = props.categories && Data.getStringsFromCategories(props, \"x\");\n  const yPropCategories = props.categories && Data.getStringsFromCategories(props, \"y\");\n  const fallbackRequired = !xPropCategories || !yPropCategories;\n  const fallbackProps = fallbackRequired ? allStrings || getStringsFromChildren(props, childComponents) : {};\n  const xCategories = xPropCategories || fallbackProps.x;\n  const yCategories = yPropCategories || fallbackProps.y;\n  return {\n    x: xCategories.length > 0 ? xCategories : undefined,\n    y: yCategories.length > 0 ? yCategories : undefined\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}